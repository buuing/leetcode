
## 622. 设计循环队列

<br />

> 力扣（LeetCode）https://leetcode-cn.com/problems/design-circular-queue

<br />

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

- 你的实现应该支持如下操作：
  - MyCircularQueue(k): 构造器，设置队列长度为 k 。
  - Front: 从队首获取元素。如果队列为空，返回 -1 。
  - Rear: 获取队尾元素。如果队列为空，返回 -1 。
  - enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
  - deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
  - isEmpty(): 检查循环队列是否为空。
  - isFull(): 检查循环队列是否已满。

- 提示：
  - 所有的值都在 0 至 1000 的范围内；
  - 操作数将在 1 至 1000 的范围内；
  - 请不要使用内置的队列库。

---

```js
// 通过52个测试用例, 执行用时：140 ms
class MyCircularQueue {
  /**
   * 数据结构 - 循环队列
   * @param { Number } k 队列的长度
   */
  constructor (k) {
    this.k = k
    this.head = -1 // 头部指针
    this.tail = -1 // 尾部指针
    this.size = 0 // 队列长度
    this.data = new Array(k)
  }
  /**
   * 从队首获取元素, 如果队列为空, 返回-1
   */
  Front () {
    return this.size === 0 ? -1 : this.data[this.head]
  }
  /**
   * 从队尾获取元素, 如果队列为空, 返回-1
   */
  Rear () {
    return this.size === 0 ? -1 : this.data[this.tail]
  }
  /**
   * 向循环队列中插入一个元素, 成功返回真
   * @param { Any } val 插入的值
   */
  enQueue (val) {
    if (this.size === this.k) return false // 队列已满
    if (this.tail === this.head && this.tail === -1) this.head++
    this.tail = this.tail === this.k - 1 ? 0 : this.tail + 1
    this.size++
    this.data[this.tail] = val
    return true
  }
  /**
   * 从循环队列中删除一个元素, 成功返回真
   */
  deQueue () {
    if (this.size === 0) return false
    delete this.data[this.head]
    this.head++
    this.size--
    if (this.size === 0) {
      this.head = -1
      this.tail = -1
    }
    if (this.head == this.k && this.size !== 0) {
      this.head = 0
    }
    return true
  }
  /**
   * 检查队列是否为空
   */
  isEmpty () {
    return this.size === 0
  }
  /**
   * 检查循环队列是否已满
   */
  isFull () {
    return this.size === this.k
  }
}
```
